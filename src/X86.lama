-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import SM;
import Collection;
import List;
import Buffer;
import Fun;
import Manifest;

-- type x86symbolicStack == List[MemLocation]
-- type x86environment == Array[Function] (contains util functions)
-- type x86code == Buffer[x86instruction] (program code)


-- Assembler language interface
-- The registers: 
-- typehint regs == Array[string]
var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

-- We can not freely operate with all register; only with 4 by now
-- typehint nRegs == integer
var nRegs = regs.length - 5;

-- For convenience we define the following synonyms for the registers: 
var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We need to know the word size to calculate offsets correctly
-- typehint wordSize == integer
var wordSize = 4;

-- type MemLocation == R(integer) | S(integer) | M(string) | L(integer)
-- We need to distinguish the following operand types: 
--    R (int)    -- hard register                    
--    S (int)    -- a position on the hardware stack 
--    M (string) -- a named memory location          
--    L (int)    -- an immediate operand             

-- type x86instruction 
-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)
                                                               
-- Machine instruction printer
-- type insnString (insn == x86instruction) == string
fun insnString (insn) {
  -- typehint binopString (op == string) == string
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    esac
  }

  -- typehint opndString (opnd == MemLocation) == string
  fun opndString (opnd) {
    
    case opnd of
      R (i) -> regs [i]
    | S (i) -> sprintf ("-%d(%%ebp)", (i+1) * wordSize)
    | M (x) -> x
    | L (i) -> sprintf ("$%d", i)
    esac
  }
  
  case insn of
    Cltd               -> "\tcltd\n"
  | Set   (suf, s)     -> sprintf ("\tset%s\t%s\n", suf, s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", c, l)
  | Meta  (m)          -> m
  esac
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names

-- typehint makeEnv (stack == x86symbolicStack, stackSlots == integer, globals == Set(string)) == x86environment 
fun makeEnv (stack, stackSlots, globals) {
  -- Returns an internal name for a global variable
  -- typehint globalName (name == string) == string
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  -- typehint envString () == string
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements (globals).string)
  }
  
  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  -- typehint allocate () == [MemLocation, x86environment]
  fun allocate () {
    case 
      case stack of
        {}        -> [ebx, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (0), 1] fi
      | _         -> [S (0), 1]
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals)]esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  -- typehint push (y == MemLocation) == x86environment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  -- typehint pop () == [MemLocation, x86environment]
  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals)]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  -- typehint pop2 () == [MemLocation, MemLocation, x86environment]
  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals)]
    esac
  }

  -- Adds a global variable; returns an updated environment
  -- typehint addGlobal (name == string) == x86environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)))
  }

  -- References a global variable
  -- typehint loc (name == string) == MemLocation
  fun loc (name) {
    M (globalName (name))
  }
  
  -- Gets a list of global variables from the environment
  -- Note: seems like this returns a list
  fun getGlobals () {
    globals.elements
  }

  -- Gets a maximal stack size from the environment
  -- typehint getStackSize() == integer
  fun getStackSize () {
    stackSlots
  }

  [envString, allocate, push, pop, pop2, addGlobal, loc, getGlobals, getStackSize]
}

-- Exported accessors
-- typehint envString (env == x86environment) == string 
fun envString (env) {
  env [0] ()
}

-- typehint allocate (env == x86environment) == [MemLocation, x86environment]
fun allocate (env) {
  env [1] ()
}

-- typehint push (env == x86environment, x == MemLocation) == x86environment
-- TODO: what does push do exactly?
fun push (env, x) {
  env [2] (x)
}

-- typehint pop (env == x86environment) == [MemLocation, x86environment]
fun pop (env) {
  env [3] ()
}

-- typehint pop2 (env == x86environment) == [MemLocation, MemLocation, x86environment]
fun pop2 (env) {
  env [4] ()
}

-- typehint addGlobal (env == x86environment, name == string) == x86environment
fun addGlobal (env, name) {
  env [5] (name)
}

-- typehint loc (env == x86environment, name == string) == MemLocation
fun loc (env, name) {
  env [6] (name)
}

-- typehint getGlobals (env == x86environment) == ??? List[str]
fun getGlobals (env) {
  env [7] ()
}

-- typehint getStackSize (env == x86environment) == integer
fun getStackSize (env) {
  env [8] ()
}

-- Creates an initial environment
-- Note: seems like init value for stackSlots is incorrect, should be of type integer 
-- typehint initEnv () == x86environment
fun initEnv () {
  makeEnv (0, emptySet (compare), emptySet (compare))
}

-- Codegeneration helper functions
-- Generates code section
-- Note: wrap x86 code into code section
-- typehint codeSection (text == x86code) == x86code
fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
-- typehint dataSection (text == x86code) == x86code
fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates data definition
-- typehint dataDef (name == string) == x86instruction
fun dataDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates function prologue
-- typehint prologue (size == integer) == x86code
fun prologue (size) {
  singletonBuffer (Push (ebp)) <+
  Mov   (esp, ebp) <+
  -- Note: reminder: symbolic stack locations decrease
  Binop ("-", L (wordSize*size), esp)
}

-- Generates function epilogue
-- typehint epilogue () == x86code
fun epilogue () {
  singletonBuffer (Mov (ebp, esp)) <+
  Pop   (ebp) <+
  Binop ("^", eax, eax) <+
  Ret
}

-- Checks if an operand resides on a stack
-- typehint stackOpnd (opnd == MemLocation) == boolean
fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
-- typehint memOpnd (opnd == MemLocation) == boolean
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
-- typehint move (from == MemLocation, to == MemLocation) == x86code
fun move (from, to) {
  if memOpnd (from) && memOpnd (to)
  then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
  else singletonBuffer (Mov (from, to))
  fi
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
-- typehint suffix (op == string) == string
fun suffix (op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}


-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
-- typehint compile (env == x86environment, code == SMCode) == x86code
fun compile (env, code) {
  foldl (
    -- typehint *accumulator anon fun* ([env == x86environment, scode == x86code], i == SMInstruction) == [x86environment, x86code]
    fun ([env, scode], i) {
      var code = scode <+ Meta ("# " ++ showSMInsn (i) ++ "\n");
      case i of
        READ ->
          case env.allocate of
            [s, env] -> [env, code <+ Call ("Lread") <+ Mov (eax, s)]
          esac
      | WRITE ->
          case env.pop of
            [s, env] -> [env, code <+ Push (s) <+ Call ("Lwrite") <+ Pop (eax)]
          esac
      | CONST (value) ->
          case env.allocate of
             [s, env] -> [env, code <+ Mov (L (value), s)]
          esac
      | LD (name) ->
          case env.addGlobal(name).allocate of
            [s, env] -> [env, code <+> move(env.loc(name), s)]
          esac
      | ST (name) ->
          case env.addGlobal(name).pop of
            [s, env] -> [env, code <+> move(s, env.loc(name))]
          esac
      | BINOP (operation) ->
          case env.pop2 of
            [x, y, env] ->
              -- For *, +, -
              fun arithmetic_operation () {
                -- code := code <+ Binop(operation, x, y);
                code :=code <+> move(y, eax) <+ Binop(operation, x, eax);
                case env.allocate of
                  [s, env] -> [env, code <+> move(eax, s)]
                esac
              }

              -- For /, %
              fun division_operation() {
                code := code  <+> move(y, eax) <+ Binop("^", edx, edx) <+ Cltd <+ IDiv(x);
                case env.allocate of
                  [s, env] -> case operation of
                    "/" -> [env, code <+> move(eax, s)]
                  | "%" -> [env, code <+> move(edx, s)]
                  esac
                esac
              }

              -- Set operand to 1 or 0 based on its equality to the zero
              fun bool(x) {
                singletonBuffer(Binop("^", eax, eax)) <+ Binop("cmp", L(0), x) <+ Set("ne", "%al") <+> move(eax, x)
              }

              -- For !!, &&
              fun logic_operation () {
                code := code <+> bool(x) <+> bool(y);

                -- Now logic operators are the same as andl, orl
                code := code <+> move(x, eax)<+Binop(operation, eax, y) ;

                case env.allocate of
                  [s, env] -> [env, code <+> move(y, s)]
                esac
              }

              -- For <, >, <=, >=, ==, !=
              fun compare_operation() {
                var command = case operation of
                  ">" -> "g"
                | ">=" -> "nl"
                | "<"  -> "l"
                | "<=" -> "ng"
                | "==" -> "e"
                | "!=" -> "ne"
                esac;

                case env.allocate of
                  [s, env] -> [env, code<+>move(x, eax)<+Binop("cmp", eax, y)<+Set(command, "%al")<+Binop("&&", L(255), eax)<+>move(eax, s)]

                esac
              }

              case operation of
                "+"     -> arithmetic_operation()
              | "*"     -> arithmetic_operation()
              | "-"     -> arithmetic_operation()
              | "/"     -> division_operation()
              | "%"     -> division_operation()
              | "&&"    -> logic_operation()
              | "!!"    -> logic_operation()
              | ">"     -> compare_operation()
              | ">="    -> compare_operation()
              | "<"     -> compare_operation()
              | "<="    -> compare_operation()
              | "=="    -> compare_operation()
              | "!="    -> compare_operation()
              | _       -> failure("Operation %s is not supported!", operation)
              esac
          esac
      | JMP (label) -> [env, code <+ Jmp("__label_"++label)]
      | LABEL (label) -> [env.addGlobal("__label_"++label), code <+ Label("__label_"++label)]
      | CJMP (mod, label) -> case env.pop of
          -- [s, env] -> [env, code <+ Push(s) <+ CJmp(mod, "__label_"++label) ]
          [s, env] -> [env, code <+> move(s, eax) <+ Binop("cmp", L(0), eax) <+ CJmp(mod, "__label_"++label)]
      esac
      | _ -> failure("Invalid stack machine instruction '%s' encountered\n", string(i))
      esac
    }, [env, emptyBuffer ()], code)
}
-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (initEnv (), code) of
    [env, code] ->
       var asmFile = args.getBaseName ++ ".s",
           runtime = case getEnv ("LAMA_RUNTIME") of
                       #val -> "../runtime/"
                     | path     -> path
                     esac ++ "/runtime.o";
       
       fwrite (asmFile,
               map (insnString, 
                    getBuffer $
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer $ map (dataDef, getGlobals (env))) <+>
                      codeSection (
                        singletonBuffer (Meta ("main:\n")) <+>
                        prologue (getStackSize (env)) <+>
                        code <+>
                        epilogue ()
                    )
                   ).stringcat);
                    
       system ({"gcc -g -m32 -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
