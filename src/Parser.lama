-- Parser 
import Matcher; --self-added
import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
        exp = memo $ eta expr(
            { -- levels (see section 2.4 of lama-spec.pdf)
                [  -- disjunction level
                    Left,
                    {
                        [s("!!"), fun(l, op, r) {Binop("!!", l, r)}]
                    }
                ],
                [   -- conjunction
                    Left,
                    {
                        [s("&&"), fun(l, op, r) {Binop("&&", l, r)}]
                    }
                ],
                [   -- integer comparisons
                    Nona, -- non-associative
                    {
                        [s("=="), fun(l, op, r) {Binop("==", l, r)}],
                        [s("!="), fun(l, op, r) {Binop("!=", l, r)}],
                        [s("<="), fun(l, op, r) {Binop("<=", l, r)}],
                        [s("<"), fun(l, op, r) {Binop("<", l, r)}],
                        [s(">="), fun(l, op, r) {Binop(">=", l, r)}],
                        [s(">"), fun(l, op, r) {Binop(">", l, r)}]
                    }

                ],
                [ -- addition, substraction
                    Left,
                    { -- operators of this level
                        [s("+"), fun(l, op, r) {Binop("+", l, r)}],
                        [s("-"), fun(l, op, r) {Binop("-", l, r)}]
                    }
                ],
                [ -- second level
                    Left,
                    { -- operators of this level
                        [s("*"), fun(l, op, r) {Binop("*", l, r)}],
                        [s("/"), fun(l, op, r) {Binop("/", l, r)}],
                        [s("%"), fun(l, op, r) {Binop("%", l, r)}]
                    }
                ]
            }, 
            primary
        );


var simple_statement = memo $ eta syntax (
    -kRead -s["("] name=lident -s[")"] {Read(name)} |
    -kWrite -s["("] expression=exp -s[")"] {Write(expression)} |
    name=lident -s[":="] expression=exp {Assn(name, expression)} 
);
var stmt = memo $ eta syntax (
    simple_statement -end | 
    first=simple_statement -s[";"] second=stmt -end {Seq(first, second)}
    );


-- Public top-level parser
public parse = stmt;
             

