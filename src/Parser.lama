-- Parser 
import Matcher; --self-added
import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
        exp = memo $ eta expr(
            { -- levels (see section 2.4 of lama-spec.pdf)
                [  -- disjunction level
                    Left,
                    {
                        [s("!!"), fun(l, op, r) {Binop("!!", l, r)}]
                    }
                ],
                [   -- conjunction
                    Left,
                    {
                        [s("&&"), fun(l, op, r) {Binop("&&", l, r)}]
                    }
                ],
                [   -- integer comparisons
                    Nona, -- non-associative
                    {
                        [s("=="), fun(l, op, r) {Binop("==", l, r)}],
                        [s("!="), fun(l, op, r) {Binop("!=", l, r)}],
                        [s("<="), fun(l, op, r) {Binop("<=", l, r)}],
                        [s("<"), fun(l, op, r) {Binop("<", l, r)}],
                        [s(">="), fun(l, op, r) {Binop(">=", l, r)}],
                        [s(">"), fun(l, op, r) {Binop(">", l, r)}]
                    }

                ],
                [ -- addition, substraction
                    Left,
                    { -- operators of this level
                        [s("+"), fun(l, op, r) {Binop("+", l, r)}],
                        [s("-"), fun(l, op, r) {Binop("-", l, r)}]
                    }
                ],
                [ -- second level
                    Left,
                    { -- operators of this level
                        [s("*"), fun(l, op, r) {Binop("*", l, r)}],
                        [s("/"), fun(l, op, r) {Binop("/", l, r)}],
                        [s("%"), fun(l, op, r) {Binop("%", l, r)}]
                    }
                ]
            }, 
            primary
        );

fun parseIfElifElse(ifBlock@[ifCondition, ifStatement], elifBlock, elseStatement) {
    case elifBlock of 
        {} -> If (ifCondition, ifStatement, elseStatement)
        | firstElif : elifBlock -> If (ifCondition, ifStatement, parseIfElifElse (firstElif, elifBlock, elseStatement))
    esac
}

var simple_statement = memo $ eta syntax (
    -kRead -s["("] name=lident -s[")"] {Read(name)} |
    -kWrite -s["("] expression=exp -s[")"] {Write(expression)} |
    name=lident -s[":="] expression=exp {Assn(name, expression)} |
    -kWhile expression=exp -kDo statement=stmt -kOd {While(expression, statement)} |
    -kDo statement=stmt -kWhile condition=exp -kOd {DoWhile(statement, condition)} |
    -kFor s1=stmt -s[","] e=exp -s[","] s2=stmt -kDo s3=stmt -kOd {Seq(s1, While (e, Seq(s3, s2)))}| 
    -kSkip {Skip} |
    -kIf ifBlock=(exp -kThen stmt) elifBlock=(-kElif exp -kThen stmt)* elseBlock=(-kElse stmt)? -kFi {parseIfElifElse(ifBlock, elifBlock, case elseBlock of Some(elseStatement) -> elseStatement | None -> Skip esac )} 
);



-- Note: `-end` in the end is added in src/Driver.lama
var stmt = memo $ eta syntax (
    simple_statement | 
    first=simple_statement -s[";"] second=stmt {Seq(first, second)}
);


-- Public top-level parser
public parse = stmt;
             

